\begin{Verbatim}[label=\makebox{\href{https://github.com/unipi-physics-labs/lab1-sheets/tree/main/snippy/random_walk.py}{https://github.com/.../random\_walk.py}},commandchars=\\\{\}]
\PY{k+kn}{import}\PY{+w}{ }\PY{n+nn}{random}
\PY{k+kn}{import}\PY{+w}{ }\PY{n+nn}{numpy}\PY{+w}{ }\PY{k}{as}\PY{+w}{ }\PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Potete generare un singolo numero pseudo\PYZhy{}casuale distributo uniformemente tra 0}
\PY{c+c1}{\PYZsh{} e 2 pi con il modulo random, parte della libreria standard di Python.}
\PY{c+c1}{\PYZsh{} Questo non è molto efficiente, ma va bene per rappresentare graficamente un}
\PY{c+c1}{\PYZsh{} random walk.}

\PY{n}{phi} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{l+m+mf}{0.}\PY{p}{,} \PY{l+m+mf}{2.} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{pi}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Se siete interessati a generare un random walk e l\PYZsq{}unica cosa che vi interessa}
\PY{c+c1}{\PYZsh{} è tenere traccia della posizione finale della particella dopo n passi, è molto}
\PY{c+c1}{\PYZsh{} più efficiente vettorizzare l\PYZsq{}operazione utilizzando il modulo random di numpy,}
\PY{c+c1}{\PYZsh{} che permette di generare array di numeri casuali}

\PY{k}{def}\PY{+w}{ }\PY{n+nf}{random\PYZus{}walk}\PY{p}{(}\PY{n}{num\PYZus{}steps}\PY{p}{)}\PY{p}{:}
\PY{+w}{    }\PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Vectorized 2\PYZhy{}dimensional random walk.}

\PY{l+s+sd}{    This generates num\PYZus{}steps random angles in the plane, and returns the final}
\PY{l+s+sd}{    position of the particle, assuming a unitary step length.}
\PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{c+c1}{\PYZsh{} Extract an array with num\PYZus{}steps angles equidistributed between 0 and 2 pi.}
    \PY{n}{phi} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{l+m+mf}{0.}\PY{p}{,} \PY{l+m+mf}{2.} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{pi}\PY{p}{,} \PY{n}{num\PYZus{}steps}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Calculate the displacemente along the two orthogonal axes at each step.}
    \PY{n}{dx} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{cos}\PY{p}{(}\PY{n}{phi}\PY{p}{)}
    \PY{n}{dy} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{sin}\PY{p}{(}\PY{n}{phi}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Sum all the displacements to get the final position.}
    \PY{n}{x} \PY{o}{=} \PY{n}{dx}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
    \PY{n}{y} \PY{o}{=} \PY{n}{dy}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Return the final position.}
    \PY{k}{return} \PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}
\end{Verbatim}
